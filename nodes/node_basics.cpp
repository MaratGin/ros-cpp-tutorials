#include <iostream>  // cout, printf

#include <ros/ros.h>  // заголовочный файл базовых сущностей в ROS
#include <std_msgs/String.h>

#include "ros_cpp_tutorials/lib.hpp"

// 1. Специальная функция, которая вызывается автоматически системой ROS
//    *при получении пакетов данных извне (из топика, на который подписаны).
//
// 2. Регистрируется в системе ROS при создании подписчика (Subscriber).
//
// 3. Все входящие сообщения (данные из топиков) сохраняются в специальной очереди (Queue)
//    и далее обрабатываются системой ROS. Эту очередь можно реализовать свою - при необходимости.
//
void message_callback(const std_msgs::String::ConstPtr& msg) {
  // Вопрос: что такое String::ConstPtr? Умный указатель?
  ROS_INFO_STREAM(" << Message: " << msg->data);
  ros::Duration(0.3).sleep();  // эмулируем работу длительностью в 300 мс
}

int main(int argc, char** argv) {
  // Инициализация ROS узла
  // Подготавливает ROS узел к запуску
  //  - задаёт название узла
  //  - настройка соединения с ROS master (порт, IP адрес)
  //  - парсит входные параметры
  ros::init(argc, argv, "ros_cpp_basics");

  // Точка доступа к ROS системе "знает что куда и как"
  // 1. Позволяет создавать publishers, subscribers, services, actions
  // 2. Обеспечивает доступ к серверу параметров (ROS parameter server)
  ros::NodeHandle nh;

  // Интерфейс (абстракция) для ПЕРЕДАЧИ данных по каналу связи (по сети TCP/UDP)
  // advertise "говорит" ROS master'y, что мы "узел ros_cpp_basics" хотим публиковать в топик "output_topic"
  // ROS master регистрирует эти данные
  ros::Publisher pub = nh.advertise<std_msgs::String>("output_topic", 10);

  // Интерфейс (абстракция) для ПОЛУЧЕНИЯ данных по каналу связи
  // Связывается с ROS master'ом - "я хочу получать данные из топика output_topic, к кому мне обратиться?"
  // subscribe регистрирует функцию, которая будет автоматически вызываться при получении сообщений из топика
  ros::Subscriber sub = nh.subscribe("output_topic", 10 /* размер очереди */, message_callback);

  // Абстракция для отсчета фиксированных промежутков времени.
  //
  // При вызове Rate::sleep() блокирует
  // выполнения текущего "потока" с момента предыдущей точки отсчёта.
  //
  // Используется для задания частоты обработки сообщений - получения и отправления.
  ros::Rate rate(1);  // 1 Гц

  // Интерфейс получения текущего времени в системе ROS.
  // Может быть симуляционным временем или системным временем (см. параметр /use_sim_time).
  //
  // Рекомендуется всегда использовать данные интерфейс для того,
  // чтобы время не расходилось между разными компонентами ROS системы (между разными узлами).
  ros::Time current_timestamp = ros::Time::now();

  while (ros::ok()) {  // проверка состояния узла ("нужно ли сворачиваться?")
    // "передача данных в топик"
    std_msgs::String msg;
    msg.data = "message payload";
    pub.publish(msg);  // интерфейс Publisher отправляет данные в созданный канал передачи данных (топик)
    ROS_INFO_STREAM("Published: " << msg.data);

    // обрабатывает очередь сообщений (сообщения могли прийти извне)
    ros::spinOnce();  // здесь могут быть вызваны функции обработки входных сообщений (callback functions)

    rate.sleep();  // мы не хотим перегружать систему, чтобы она работала как бешеная
    // поэтому сделаем пауза при необходимости (работаем с установленной частотой)
  }

  // если мы оказались здесь, то это значит, что пользователь мог запросить завершение программы (Ctrl + C)

  return 0;
}

// Задания:
// 1. Подпишитесь на топик output_topic ещё раз с другой callback функцией.
// 2. Вопрос: в каком порядке вызываются callback функции? Выполняются ли они в одном потоке?
// 3. Сделайте так, чтобы получение данных из топика выполнялась параллельно (в разных потоках).
