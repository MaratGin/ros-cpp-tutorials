#include <iostream>  // cout

// Базовый класс
class Animal {
  // по-умолчанию все поля класса private ...
public:  // задаём public пространство
  // метод класса с базовой реализацией
  void eat() {
    std::cout << "Я могу кушать базовые продукты.\n";
  }
};

// Производный класс (наследник)
// Мотивация:
//  - расширить возможности базового класса
//  - задать иное поведение (переопределение) присущее наследнику
class Dog : public Animal {  // самое обычное наследование ("наследование нормального человека")
public:
  // Задание 1: переопределите поведение Animal::eat()

  // расширение возможностей - можем лаять
  void bark() {
    std::cout << "Я могу лаять! Гав-гав...\n";
  }
};

// Задание 2: реализуйте класс Cat
//  - наследуйтесь от Animal
//  - переопределите поведение "пожирания еды" Animal::eat()
//  - добавьте новую возможность "долго спать" - Cat::sleep()
class Cat /* ... */ {
  // ...
};

// Задание 3: добавьте во все классы (для отслеживания жизненного цикла):
// - конструктор (по-умолчанию)
// - деструктор

int main(int argc, char const* argv[]) {
  {                          // область видимости (scope)
    auto animal = Animal();  // Вопрос 1: какой конструктор вызывается и почему он доступен?
    std::cout << "Я животное.\n";
    animal.eat();
  }  // Вопрос 2: почему объект animal здесь автоматичеки "уничтожится"?

  {
    auto dog = Dog();
    std::cout << "Я собака.\n";
    dog.eat();   // унаследованный метод (был переопределён)
    dog.bark();  // новое поведение (в добавок к унаследованному)
  }

  {
    auto cat = Cat();
    std::cout << "Я кот.\n";
    // cat.eat();
    // cat.sleep();
  }

  // Дополнения: object slicing и статическое связывание
  {
    Animal dog = Dog();  // обратите внимание на тип объекта
    dog.eat();           // Вопрос 3: какой метод вызовется Animal::eat() или Dog::eat()?

    // ошибка: Animal не имеет метода bark()
    // dog.bark();
  }

  return 0;
}
